# üéÑ Advent of Code Solutions

Solutions to [Advent of Code](https://adventofcode.com/) challenges. Advent of Code is an annual coding event with daily programming puzzles released from December 1st to December 25th.

## üöÄ Solutions

### 2024 Progress: 12/25 ‚≠ê‚≠ê

 Day | Part 1 | Part 2 | Solution to P1 | Solution to P2
-----|:------:|:------:|:----------:|:----------:
[![Day 1](https://img.shields.io/badge/Day%201-Historian%20Hysteria-blue?logo=Archlinux)](https://adventofcode.com/2024/day/1) | ‚≠ê | ‚≠ê | [![Solution](https://img.shields.io/badge/C%2B%2B-purple?logo=C%2B%2B)](2024/Day1/1_PairAndAdd.cpp) |[![Solution](https://img.shields.io/badge/C%2B%2B-purple?logo=C%2B%2B)](2024/Day1/2_CountDulpicateTimes.cpp)
[![Day 2](https://img.shields.io/badge/Day%202-Red--Nosed%20Reports-blue?logo=Archlinux)](https://adventofcode.com/2024/day/2) | ‚≠ê | ‚≠ê | [![Solution](https://img.shields.io/badge/C%2B%2B-purple?logo=C%2B%2B)](2024/Day2/1_CheckLevels.cpp) |[![Solution](https://img.shields.io/badge/C%2B%2B-purple?logo=C%2B%2B)](2024/Day2/2_CheckLevels_Dampener.cpp)
[![Day 3](https://img.shields.io/badge/Day%203-Mull%20It%20Over-blue?logo=Archlinux)](https://adventofcode.com/2024/day/3) | ‚≠ê | ‚≠ê | [![Solution](https://img.shields.io/badge/C%2B%2B-purple?logo=C%2B%2B)](2024/Day3/1_FindMul.cpp) |[![Solution](https://img.shields.io/badge/C%2B%2B-purple?logo=C%2B%2B)](2024/Day3/2_PreciseMul.cpp)
[![Day 4](https://img.shields.io/badge/Day%204-Ceres%20Search-blue?logo=Archlinux)](https://adventofcode.com/2024/day/4) | ‚≠ê | ‚≠ê | [![Solution](https://img.shields.io/badge/C%2B%2B-purple?logo=C%2B%2B)](2024/Day4/1_CeresSearch.cpp) |[![Solution](https://img.shields.io/badge/C%2B%2B-purple?logo=C%2B%2B)](2024/Day4/2_XMAS.cpp)
[![Day 5](https://img.shields.io/badge/Day%205-Print%20Queue-blue?logo=Archlinux)](https://adventofcode.com/2024/day/5) | ‚≠ê | ‚≠ê | [![Solution](https://img.shields.io/badge/C%2B%2B-purple?logo=C%2B%2B)](2024/Day5/1_OrderingUpdates.cpp) |[![Solution](https://img.shields.io/badge/C%2B%2B-purple?logo=C%2B%2B)](2024/Day5/2_OrderingUpdates.cpp)
[![Day 6](https://img.shields.io/badge/Day%206-Guard%20Gallivant-blue?logo=Archlinux)](https://adventofcode.com/2024/day/6) | ‚≠ê |‚≠ê| [![Solution](https://img.shields.io/badge/C%2B%2B-purple?logo=C%2B%2B)](2024/Day6/1_PatrolRoute.cpp)|[![Solution](https://img.shields.io/badge/C%2B%2B-purple?logo=C%2B%2B)](2024/Day6/2_CircleObstacle.cpp)
[![Day 7](https://img.shields.io/badge/Day%207-Bridge%20Repair-blue?logo=Archlinux)](https://adventofcode.com/2024/day/7) |‚≠ê|‚≠ê|[![Solution](https://img.shields.io/badge/C%2B%2B-purple?logo=C%2B%2B)](2024/Day7/1_Caliration.cpp)|[![Solution](https://img.shields.io/badge/C%2B%2B-purple?logo=C%2B%2B)](2024/Day7/2_CombineCalibration.cpp)
[![Day 8](https://img.shields.io/badge/Day%208-Resonant%20Collinearity-blue?logo=Archlinux)](https://adventofcode.com/2024/day/8) |‚≠ê|‚≠ê|[![Solution](https://img.shields.io/badge/C%2B%2B-purple?logo=C%2B%2B)](2024/Day8/1_AntinodesCnt.cpp)|[![Solution](https://img.shields.io/badge/C%2B%2B-purple?logo=C%2B%2B)](2024/Day8/2_AntinodeHarmonic.cpp)
[![Day 9](https://img.shields.io/badge/Day%209-Disk%20Fragmenter-blue?logo=Archlinux)](https://adventofcode.com/2024/day/9) |‚≠ê|‚≠ê|[![Solution](https://img.shields.io/badge/C%2B%2B-purple?logo=C%2B%2B)](2024/Day9/1_compactingBlocks.cpp)|[![Solution](https://img.shields.io/badge/C%2B%2B-purple?logo=C%2B%2B)](2024/Day9/2_compactingFiles.cpp)
[![Day 10](https://img.shields.io/badge/Day%2010-Hoof%20It-blue?logo=Archlinux)](https://adventofcode.com/2024/day/10) |‚≠ê|‚≠ê|[![Solution](https://img.shields.io/badge/C%2B%2B-purple?logo=C%2B%2B)](2024/Day10/1_trailScore.cpp)|[![Solution](https://img.shields.io/badge/C%2B%2B-purple?logo=C%2B%2B)](2024/Day10/2_ttrailScore.cpp)
[![Day 11](https://img.shields.io/badge/Day%2011-Plutonian%20Pebbles-blue?logo=Archlinux)](https://adventofcode.com/2024/day/11) |‚≠ê|‚≠ê|[![Solution](https://img.shields.io/badge/C%2B%2B-purple?logo=C%2B%2B)](2024/Day11/1_TwinkleStones.cpp)|[![Solution](https://img.shields.io/badge/C%2B%2B-purple?logo=C%2B%2B)](2024/Day11/2_DPTwinkle.cpp)
[![Day 12](https://img.shields.io/badge/Day%2012-Garden%20Groups-blue?logo=Archlinux)](https://adventofcode.com/2024/day/12) |‚≠ê|‚≠ê|[![Solution](https://img.shields.io/badge/C%2B%2B-purple?logo=C%2B%2B)](2024/Day12/1_perimeter.cpp)|[![Solution](https://img.shields.io/badge/C%2B%2B-purple?logo=C%2B%2B)](2024/Day12/2_edge.cpp)
[![Day 25](https://img.shields.io/badge/Day%2025-Code%20Chroncile-blue?logo=Archlinux)](https://adventofcode.com/2024/day/25) |‚≠ê|24‚≠ê lack|[![Solution](https://img.shields.io/badge/C%2B%2B-purple?logo=C%2B%2B)](2024/Day25/1_clockKeyPair.cpp)|-

## üíª Tools

- IDE : [![VSCode](<Images/code-stable.png>)](https://code.visualstudio.com) [![VsCode](https://img.shields.io/badge/VsCode-blue)](https://code.visualstudio.com)
- Compiler: ![G++](https://img.shields.io/badge/(GCC)%2014.2.1%2020240910-grey)
- C++ standard: ![C++17](https://img.shields.io/badge/C%2B%2B14-purple?logo=C%2B%2B)
- OS: [![Arch Linux](https://img.shields.io/badge/Arch%20Linux-grey?logo=Archlinux)](https://www.archlinux.org)

## üìú Worth future utility

### Day 9 Disk Fragmenter

[![Original](Images/Day9DiskFragmentOriginal.png)](2024/Day9/2_compactingFiles.cpp)
[![Output](Images/Day9DiskFragmentOutput.png)](2024/Day9/2_compactingFiles.cpp)

### Day 11 Plutonian Pebbles

The multithreading aproach has crashed my OS many times. The dynamic programming method is fruitful. However, what if the position of spawned stones matters in the result calculation?

### Day 12 Garden Groups

This problem guides a way of image edge detection algorithm.
![Edge detection](Images/EdgeDetection.png)

## üîó Links

- [Advent of Code](https://adventofcode.com/)
- [About Advent of Code](https://adventofcode.com/about)
- [This README's template](https://github.com/TrueBurn/advent-of-code)
- [Markdown emoji](<https://gist.github.com/rxaviers/7360908>)

## üìÜ TODOs

- Change Day3 algorithm to [regular expression](https://en.cppreference.com/w/cpp/regex/ecmascript) implementation([C++11 feature](https://en.cppreference.com/w/cpp/regex)).

## Regex grammar

A regular expression pattern is a sequence of one or more Alternatives, separated by the disjunction operator | (in other words, the disjunction operator has the lowest precedence).

Pattern = Disjunction = Alternative | Alternative | ...

Alternative(Can be empty) = [Sequence of Alternative Terms]

Alternative Term(not empty) = [Assertion] [Atom] [Atom Quantifier]

Quantifier = QuantifierPrefix [?]

Assertion = ^,$,\b,\B,( ? = Disjunction ),( ? ! Disjunction )

QuantifierPrefix = *,+,?,{ DecimalDigits },{ DecimalDigits , },{ DecimalDigits , DecimalDigits }

Atom = PatternCharacter,.,\ AtomEscape,CharacterClass,( Disjunction ),( ? : Disjunction )

### Alternatives

*Pattern* ::

>*Disjunction*

- Also, if Disjunction can match at the current position in several ways, *only the first* one is tried. This is the same logic as || operator in C++.

*Disjunction* ::

>*Alternative*

>*Alternative* | *Disjunction*

### Terms

Each Alternative is either empty or is a **sequence** of Terms (with **no separators** between the Terms)

*Alternative* ::

>[empty]

>Alternative Term

- Empty Alternative always matches and does not consume any input.
- Between alternatives (Disjunctions), if the former Term matched the remainder of the regular expression is not tried.

### Quantifiers

*Term* ::

>*Assertion*

>*Atom*

>*Atom* *Quantifier*

*Quantifier* ::

>*QuantifierPrefix*

>*QuantifierPrefix* **?**

QuantifierPrefix|Minimum|Maximum
----------------|-------|-------
`*`|zero|infinity
`+`|one|infinity
`?`|zero|one
`{ DecimalDigits }`|value of DecimalDigits |value of DecimalDigits
`{ DecimalDigits , }`|value of DecimalDigits |infinity
`{ DecimalDigits , DecimalDigits }`|value of DecimalDigits before the comma |value of DecimalDigits after the comma

Remark: the backreferenced term inside parenthesis is the final regex matched result, but gcc got it wrong. It does not correctly clear the matches[4] capture group as required by ECMA-262 21.2.2.5.1, and thus incorrectly captures "bbb" for that group (see [cpp reference #Quantifiers][Quantifiers]).

gcc|g++
-|-
smatch: m[0]=[zaacbbbcac] m[1]=[z] m[2]=[ac] m[3]=[a] `m[4]=[bbb]` m[5]=[c] |smatch: m[0]=[zaacbbbcac] m[1]=[z] m[2]=[ac] m[3]=[a] `m[4]=[]` m[5]=[c]

### Assertion

Assertions (also called lookahead Assertion) match conditions, rather than substrings of the input string. They never consume any characters from the input.
>`^`

- The position that immediately follows a *LineTerminator* character (Enable: `std::regex_constants::multiline`)
- The beginning of the input (Disable: `std::regex_constants::match_not_bol`)

>`$`

- The position of a LineTerminator character (Enable: `std::regex_constants::multiline`)
- The end of the input (Disable: `std::regex_constants::match_not_eol`)

In the two Assertions above and in the Atom `.`(match any character) below, LineTerminator is one of the following four characters: `U+000A` (`\n`or line feed), `U+000D` (`\r` or carriage return), `U+2028` (`line separator`), or `U+2029` (`paragraph separator`), see [Unicode Character U+2028](https://www.compart.com/en/unicode/U+2028)

```shell
sudo pacman -S wget
wget ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt
```

>`\b` : word boundary
<!-- TODO test if enable match_not_bow/match_not_eow, word begins/ends with a-z will not be matched  -->
- The **beginning/end** of *a word* (current character is/isn't a letter, digit, or underscore, and the previous character isn't/is one of those)
- The **beginning/end** of *the input* (the first character is not a letter, digit, or underscore )(Disable: `std::regex_constants::match_not_bow`, `std::regex_constants::match_not_eow`)

>`\B` : negative word boundary, match *except* :

- The **beginning/end** of *a word/the input*

>`( ? = Disjunction )`

- The Assertion ( ? = Disjunction ) (zero-width positive lookahead) matches if Disjunction would match the input at the current position.
- Positive lookahead Assertion does **not** consume letters, positive Assertion succeeds if the pattern inside the lookahead **succeeds**. or it will try the remainder of the disjunction.

>`( ? ! Disjunction )`

- The Assertion ( ? ! Disjunction ) (zero-width negative lookahead) matches if Disjunction would NOT match the input at the current position.
- Negative lookahead Assertion does **not** cosume letters, negative Assertion succeeds if the pattern inside the look =ahead **fails**, which requies all alternative terms in the disjunction unmatched.

ECMAScript **forbids** backtracking into the lookahead Disjunctions, which affects the behavior of backreferences into a **positive lookahead** from the remainder of the regular expression (see example below). Backreferences into the **negative lookahead** from the rest of the regular expression are always **undefined** (since the lookahead Disjunction must fail to proceed, and if it is failed there is no reason backreferencing to it).

### Match Order

Within a *Alternative*'s choice point, the *alternative* term (*Atom*) is matched **as many** (or as few, if non-greedy) times as possible **in the first repetition**, during which the *Atom* will begin to match with **Minimum** *Quantifier* times and repeat to match more of the input(if greedy *Quantifier*, or stops if not greedy) or move to the next *Disjunction* within the *Term* if fails to match. All choice points in the remainder of the regular expression are tried **before** moving on to the next choice in the last repetition of Atom.

<!-- References -->
[Quantifiers]: https://en.cppreference.com/w/cpp/regex/ecmascript#Quantifiers
